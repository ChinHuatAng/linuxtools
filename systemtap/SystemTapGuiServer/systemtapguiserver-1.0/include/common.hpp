#ifndef COMMON_H_
#define COMMON_H_

#include <stdint.h>
#include <string>

using std::string;

namespace datamanager
{
	/* static intitializations */
	const string SCRIPTLIST = "/var/tmp/dmd/script_list.conf";
	const string SCRIPT_DIR = "/var/tmp/dmd/scripts/";

	struct dmRequest * reqConvToH(struct dmRequest *req);
	struct dmRequest * reqConvToN(struct dmRequest *req);
	struct dmResponse * respConvToH(struct dmResponse *resp);
	struct dmResponse * respConvToN(struct dmResponse *resp);
	void printReq(struct dmRequest *req);
	bool printResp(struct dmResponse *resp);
	int forceNonBlocking(int fd);

	/* definitions/declarations possibly needed by a client app */

	/* Message passed to datamanager to indicate requested shutdown */
	static const int SHUTDOWN_DATAMANAGER = -1;

	/* Identifies beginning of a stap-gui packet */
	static const uint32_t DM_PACKET_BEGIN = 0xa1b2c3d4;

	/* primary port for socket communication with
		subscription manager */
	static const int LISTEN_PORT = 22462;
	static const int TIMEOUT_FOR_LISTEN = 5; /* seconds */

	/* Valid request types */
	enum reqAction_t {
		REQ_CREATE_CONN = 1,
		REQ_SUBSCRIBE,
		REQ_UNSUBSCRIBE,
		REQ_GET_STATUS,
		REQ_SUBSCRIPTION_MODIFY,
		REQ_DESTROY_CONN,
		REQ_CONFIG_FILE  /* TODO : Add support for this. Sends servers
					script_list.conf file to client */
	};

	enum reqType_t {
		SYSTEM_TAP = 1,
		BLUEDYE,
		SHELL,
                STP,
                STP_GURU 
	};

	/* For requests sent from client or dashboard to subscriptionMgr */
	struct dmRequest {
		uint32_t beginIdStr; /* DM_PACKET_BEGIN or other as needed */
		uint32_t reqAction; /* action to take on specified service */
		uint32_t scriptID;
		uint32_t clientID;  /* Unique id, set to 0 for first subscription req,
	       							then set to assigned id for future req's */
                uint32_t guru;
		uint32_t size; /* size of data */
	        char data[20]; /* For requests requiring passing of added data */
	};

	enum dmResponseDataSources {
		STDOUT = 1,
		STDERR,
		SUBSCRIPTION_MGR,
		DATA_MGR,
		MAILBOX
	};

	/* Response Packet: for packaging by mailbox, will be sent in this format
	 *  to client (consumer) */
	struct dmResponse {
		uint32_t beginIdStr;	/* DM_PACKET_BEGIN or other as needed */
		uint32_t src; 			/* identifies data or error source -lookup in dmResponseDataSources */
		uint32_t scriptID;
		uint32_t clientID; 		/* Unique id, generated by data manager during first
							       request, then included with all data packets */
		uint32_t returnCode;	/* Optional return code from request */
		uint32_t size; 			/* size of data */
		void *data;
	};

        struct dmResponse_header {
                uint32_t beginIdStr;    /* DM_PACKET_BEGIN or other as needed */
                uint32_t src;                   /* identifies data or error source -lookup in dmResponseDataSources */
                uint32_t scriptID;
                uint32_t clientID;              /* Unique id, generated by data manager during first
                                                               request, then included with all data packets */
                uint32_t returnCode;     /* Optional return code from request */
                uint32_t size;                  /* size of data */
            };   

	/* Holds data as read from script_list.conf */
	struct scriptElement {
		int scriptType;
		int scriptNum;
		string scriptName;
		string format_str; /* describes format of data returned from script */
		string args;
		int valid;
	};

}

#endif /*COMMON_H_*/

